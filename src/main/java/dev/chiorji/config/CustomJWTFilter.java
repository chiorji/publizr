package dev.chiorji.config;import com.auth0.jwt.*;import com.auth0.jwt.algorithms.*;import com.auth0.jwt.exceptions.*;import com.auth0.jwt.interfaces.*;import jakarta.servlet.*;import jakarta.servlet.http.*;import java.io.*;import java.util.*;import org.apache.logging.log4j.*;import org.springframework.http.*;import org.springframework.web.filter.*;public class CustomJWTFilter extends GenericFilterBean {	private static final Logger log = LogManager.getLogger(CustomJWTFilter.class);	private final String secretKey;	private final String tokenIssuer;	public CustomJWTFilter(String secretKey, String tokenIssuer) {		this.secretKey = secretKey;		this.tokenIssuer = tokenIssuer;	}	@Override	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {		HttpServletRequest httpServletRequest = (HttpServletRequest) request;		HttpServletResponse httpServletResponse = (HttpServletResponse) response;		try {			String token = this.getBearerTokenFromRequest((HttpServletRequest) request);			this.validateJWTToken(token);			Map<String, Claim> claims = extractJWTClaims(token);			if (claims.isEmpty()) {				httpServletResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, "Authorization failed");				return;			}			log.info("Extracted claims in CustomJWTFilter --> {} <--", claims);			httpServletRequest.setAttribute("claims", claims);		} catch (Exception e) {			log.error("JWT Decoding Error: --> {} <--", e.getMessage());			httpServletResponse.sendError(HttpStatus.FORBIDDEN.value(), "INVALID OR EXPIRED AUTHORIZATION TOKEN");			return;		}		chain.doFilter(request, response);	}	private String getBearerTokenFromRequest(HttpServletRequest request) {		String header = request.getHeader("Authorization");		if (header == null) return null;		return header.replace("Bearer ", "");	}	private void validateJWTToken(String jwtToken) {		try {			Algorithm algorithm = Algorithm.HMAC256(secretKey);			JWT.require(algorithm)				.withIssuer(tokenIssuer)				.build()				.verify(jwtToken);		} catch (JWTVerificationException e) {			throw new RuntimeException(e);		}	}	private Map<String, Claim> extractJWTClaims(String jwtToken) {		Algorithm algorithm = Algorithm.HMAC256(secretKey);		return JWT.require(algorithm).withIssuer(tokenIssuer).build().verify(jwtToken).getClaims();	}}